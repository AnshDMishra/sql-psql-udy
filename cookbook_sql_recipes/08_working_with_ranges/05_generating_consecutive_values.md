# Generating Consecutive Numeric Values

You would like to have a “**row source generator**” available to you in your queries. Row source generators are useful for queries that require **pivoting**.

For example, you want to return a result set such as the following, up to any number of rows that you specify:

|id|
|:-:|
| 1|
| 2|
| 3|
| 4|
| 5|
| 6|
| 7|
| 8|
| 9|
|10|


## Solution

If your RDBMS provides built-in functions for returning rows dynamically, you do not need to create a pivot table in advance with a fixed number of rows. That’s why a dynamic row generator can be so handy. Otherwise, you must use a traditional pivot table with a fixed number of rows (that may not always be enough) to generate rows when needed.

This solution shows how to return `10` rows of increasing numbers starting from 1. You can easily adapt the solution to return any number of rows.
The ability to return increasing values from one opens the door to many other solu‐ tions. For example, you can generate numbers to add to dates in order to generate sequences of days. You can also use such numbers to parse through strings.


- **PostgreSQL**

Use the handy function `GENERATE_SERIES`, which is designed for the express purpose of generating rows:

```SQL
SELECT GENERATE_SERIES(1,10) id;
```

|id|
|:-:|
| 1|
| 2|
| 3|
| 4|
| 5|
| 6|
| 7|
| 8|
| 9|
|10|


All the work is done by the function `GENERATE_SERIES`. The function accepts three parameters, all numeric values.
- The first parameter is the `start value`,
- the second parameter is the `ending value`, and
- the third parameter is an optional “`step`” value (how much each value is incremented by). If you do not pass a third parameter, the `increment defaults to one`.


The `GENERATE_SERIES` function is flexible enough so that you do not have to hardcode parameters. For example, if you wanted to return `5 rows` starting from value `10` and ending with value `30`, incrementing by `5` such that the result set is the following:

```SQL
SELECT GENERATE_SERIES(10,30,5) id;
```

|id|
|:--:|
| 10|
| 15|
| 20|
| 25|
| 30|

you can be creative and do something like this:

```SQL
SELECT id
  FROM GENERATE_SERIES(
        (SELECT MIN(deptno) FROM emp),
        (SELECT MAX(deptno) FROM emp),
        5) x(id);
```

Notice here that the actual values passed to GENERATE_SERIES are not known when the query is written. Instead, they are generated by subqueries when the main query executes.

- **Solution 2**:

Use the recursive WITH clause to generate a sequence of rows with incrementing val‐ ues. Using a recursive CTE will in fact work with the majority of RDBMSs today:


```SQL
WITH RECURSIVE x (id) AS (
  SELECT 1
  UNION ALL
  SELECT id+1
    FROM x
   WHERE id+1 <= 10
)
SELECT * FROM x;
```

|id|
|:--:|
| 1|
| 2|
| 3|
| 4|
| 5|
| 6|
| 7|
| 8|
| 9|
|10|
