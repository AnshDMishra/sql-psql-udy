# UniY - Populate Tables within Transaction

In the previous lesson we illustrated how to delete (destroy) all the tables of a database,(destroy the database schema), using the `DROP TABLE` statement and the `CASCADE` clause. We also explained how to include these statements in a script, `uniy-db.sql`, documenting the code with comments and extending the file with the creation of the database schema  using the `CREATE TABLE` statement.

Now, the database schema is ready and it's time to populate the tables with new records.

In this lesson we'll complete the implementation of the `uniy-db.sql` file.

1. First, we introduce the notion of `TRANSACTION` and then
2. Execute the `INSERT INTO` statemnt within a `TRANSACTION` to populate the `uniy` databse tables.

## What is a TRANSACTION ?

The `Transaction` is not a new word we are hearing. We heard that word many times like “*Cash Transaction*”. Banks usually deal with cash i.e sending or receiving cash, hence we coin the term as a cash transaction. A classical example of a transaction is a bank transfer from one account to another. A complete transaction must ensure a balance between the sender and receiver accounts. It means that if the sender account transfers `X` amount, the receiver receives `X` amount, no more or no less.

So simply transaction **is a unit of work** that **consits of one or more operations**. In this lesson, we are going to learn about transactions in the PostgreSQL database language.

Transactions are important in any database language, whenever we want
- to add,
- delete and
- update

then `transactions` are used for **keeping the integrity of data and several other reasons**.

Even without the transactions we can add, delete and update the database but there are so high chances to data gets corrected due to loss of data integrity.

### Properties of Transaction

Now let’s see the `ACID` properties of a transaction:

- **Atomicity** – This property ensures that all the transactions are complete. It follows all or none property i.e the transaction should not be partially completed. In other words, Atomicity guarantees that the transaction completes in an **all-or-nothing manner**.
- **Consistency** – This property ensures that all the transactions are consistent i.e after committing the transaction those changes are properly updated in the database or not. In other words, Consistentcy ensures the change to data written to the database **must be valid and follow predefined rules**.
- **Isolation** – determines how transaction integrity is visible to other transactions. When two transactions are running then both the transactions will have their own privacy i.e **one transaction won’t disturb another transaction**.
- **Durability** – This property ensures that even at the time of system failures the committed data in database is secure i.e permanently. Therefore, Durablity makes sure that transactions that have been committed will be stored in the database permanently.

### Commands in a Transaction
There are three main commands in a transaction block. They are:

1. **BEGIN**
2. **COMMIT**
3. **ROLLBACK**

**General syntax**

```console
BEGIN;

-- set of statements

[COMMIT | ROLLBACK]
```

Now we will understand the importance of each and every transaction control command, for that, we have to set up a table in the database first.

### Setting up a sample Table

```console
DROP TABLE IF EXISTS accounts;

CREATE TABLE accounts (
   id INT GENERATED BY DEFAULT AS IDENTITY,
   name VARCHAR(100) NOT NULL,
   balance DEC(15,2) NOT NULL,
   PRIMARY KEY(id)
);
```

The table has an automatic sequence for the primary key `id` with the [GENRATED BY DEFAULT AS IDENTITY](https://www.postgresqltutorial.com/postgresql-tutorial/postgresql-identity-column/).

### Begin Transaction

`BEGIN` command is used **to initiate a transaction**. To start a transaction we should give BEGIN command at first if we don’t give it like that then the database can't able recognizes the transaction.

Now, we'll be using two users, `usertest` and `ludovicopinzari`, to connect to the `uniy` sample database. Therefore, there will be two connections or sessions active in the following examples.

In the command line prompt there will be two open tabs with two active sessions.

**usertest**

```console
(base) ludo /Sql_udacity  $  psql uniy -U usertest
psql (11.4)
Type "help" for help.

uniy=> \conninfo
You are connected to database "uniy" as user "usertest" via socket in "/tmp" at port "5432".
```

**ludovicopinzari**

```console
(base) ludo /Sql_udacity  $  psql uniy
psql (11.4)
Type "help" for help.

uniy=# \conninfo
You are connected to database "uniy" as user "ludovicopinzari" via socket in "/tmp" at port "5432".
```

When you execute the following `INSERT` statement:

```console
INSERT INTO accounts
       (name,balance)
VALUES
       ('Bob',10000);
```

PostgreSQL inserted a new row into the `accounts` table immediately. In this case, **you do not know when the transaction begins and cannot intercept the modification such as rolling it back**.

Let's execute the `INSERT INTO` statement with the `usertest` account.

**usertest** session:

```console
uniy=> INSERT INTO accounts
uniy->        (name, balance)
uniy-> VALUES
uniy->        ('Bob',10000);
INSERT 0 1
uniy=> SELECT * FROM accounts;
 id | name | balance
----+------+----------
  1 | Bob  | 10000.00
(1 row)
```

Now, if we switch to the `ludovicopinzari` account and list the records in the `accounts` table, the dbms will output the same record:

**ludovicopinzari** session.

```console
uniy=# SELECT * FROM accounts;
 id | name | balance
----+------+----------
  1 | Bob  | 10000.00
(1 row)
```

Let's try now a `TRANSACTION` using the `usertest` account.

To start a transaction, you use the following statement:

```console
BEGIN TRANSACTION;
```

Or

```console
BEGIN WORK;
```

Or just:

```console
BEGIN;
```

For example, the following statements

- start a new transaction and
- insert a new account into the accounts table:

```console
BEGIN TRANSACTION;

INSERT INTO accounts
       (name,balance)
VALUES
       ('Alice',10000);
```

Let's execute the insertion with the `usertest`'s session.

**usertest** session:

```console
uniy=> BEGIN TRANSACTION;
BEGIN
uniy=> INSERT INTO accounts
uniy->        (name, balance)
uniy-> VALUES
uniy->        ('Alice', 10000);
INSERT 0 1
```

Let's list all the records in the `accounts` table:

```console
uniy=> SELECT * FROM accounts;
 id | name  | balance
----+-------+----------
  1 | Bob   | 10000.00
  2 | Alice | 10000.00
(2 rows)
```
From the current session, you can see the change by querying the accounts table.

**ludovicopinzari** session:

```console
uniy=# SELECT * FROM accounts;
 id | name | balance
----+------+----------
  1 | Bob  | 10000.00
(1 row)
```
However, if you switch to the other session and execute the query above, you will not see the change.

### Commit a transaction

`COMMIT` command is used **to save changes and reflect them in the database** whenever we display the required data. For suppose we updated data in the database but we didn’t give COMMIT then the changes are not reflected in the database. To save the changes done in a transaction, we should COMMIT that transaction for sure.

To make the change become visible to other sessions (or users) you need to commit the transaction by using the `COMMIT WORK` statement:

```console
COMMIT WORK;
```

Or

```console
COMMIT TRANSACTION;
```

Or simply

```console
COMMIT;
```

**usertest** session.

Now, we execute the `COMMIT TRANSACTION` command in the `usertest`'s session.

```console
uniy-> COMMIT TRANSACTION;
```

So, the entire transaction is:

```console
-- start a transaction
BEGIN;

-- insert a new row into the accounts table
INSERT INTO accounts
       (name,balance)
VALUES ('Alice',10000);

-- commit the change (or roll it back later)
COMMIT;
```
The complete history commands in the `usertest` session:

```console
uniy=> BEGIN TRANSACTION;
BEGIN
uniy=> INSERT INTO accounts
uniy->        (name, balance)
uniy-> VALUES
uniy->        ('Alice', 10000);
INSERT 0 1
uniy=> SELECT * FROM accounts;
 id | name  | balance
----+-------+----------
  1 | Bob   | 10000.00
  2 | Alice | 10000.00
(2 rows)

uniy=> COMMIT TRANSACTION;
COMMIT
```

Now, if we switch to the other session.

**ludovicopinzari** session.

```console
uniy=# SELECT * FROM accounts;
 id | name  | balance
----+-------+----------
  1 | Bob   | 10000.00
  2 | Alice | 10000.00
(2 rows)
```

After executing the COMMIT statement, PostgreSQL also guarantees that the change will be durable if a crash happens.

## PostgreSQL COMMIT: Bank account transfer example

In this demonstration, we will show you how to transfer `1000USD` from Bob’s account to Alice’s account. We will use two sessions for viewing the change of each operation.

In the first session, start a new transaction:

**usertest** session.

```console
uniy=> BEGIN;
BEGIN
```

and subtracting `1000`USD from Bob’s account with id `1`:

```console
uniy=> UPDATE accounts
uniy->    SET balance = balance - 1000
uniy->  WHERE id = 1;
UPDATE 1
```

**ludovicopinzari** session.

In the second session, check the account balance of both accounts:

```console
uniy=# SELECT * FROM accounts;
 id | name  | balance
----+-------+----------
  1 | Bob   | 10000.00
  2 | Alice | 10000.00
(2 rows)
```
As you can see, the change is not visible in other sessions.

**usertest** session.

Next, add the same amount (`1000`USD ) to Alice’s account:

```console
uniy=> UPDATE accounts
uniy->    SET balance = balance + 1000
uniy->  WHERE id = 2
uniy-> RETURNING *;
 id | name  | balance
----+-------+----------
  2 | Alice | 11000.00
(1 row)

UPDATE 1
```

**ludovicopinzari** session.

```console
uniy=# SELECT * FROM accounts;
 id | name  | balance
----+-------+----------
  1 | Bob   | 10000.00
  2 | Alice | 10000.00
(2 rows)
```
This change also is not visible to the second session until we commit it.

**usertest** session.

```console
uniy=> COMMIT;
COMMIT
```

**ludovicopinzari** session.

```console
uniy=# SELECT * FROM accounts;
 id | name  | balance
----+-------+----------
  1 | Bob   |  9000.00
  2 | Alice | 11000.00
(2 rows)
```

Put it all together.

**usertest** TRANSACTION:

```console
-- start a transaction
BEGIN;

-- deduct 1000 from account 1
UPDATE accounts
   SET balance = balance - 1000
 WHERE id = 1;

-- add 1000 to account 2
UPDATE accounts
   SET balance = balance + 1000
 WHERE id = 2;

-- select the data from accounts
SELECT *
  FROM accounts;

-- commit the transaction
COMMIT;
```

## Rolling Back a Transaction

`ROLLBACK` command is used **to undo the changes done in transactions**. As we know transactions in database languages are used for purpose of large computations, for example in banks. For suppose, the employee of the bank incremented the balance record of the wrong person mistakenly then he can simply rollback and can go to the previous state.

To roll back or undo the change of the current transaction, you use any of the following statement:

```console
ROLLBACK WORK;
```

Or

```console
ROLLBACK TRANSACTION;
```

Or in short:

```console
ROLLBACK;
```

Suppose, you want to transfer `1500`USD from Bob’s account to Alice’s account. However, you accidentally send the money to Jack’s account instead of Alice’s. And you want to roll back the whole transaction.

**usertest** session.

First, add `Jack`’s account to the **accounts** table:

```console
uniy=> INSERT INTO accounts
uniy->        (name, balance)
uniy-> VALUES ('Jack',0);
INSERT 0 1
uniy=> SELECT * FROM accounts;
 id | name  | balance
----+-------+----------
  1 | Bob   |  9000.00
  2 | Alice | 11000.00
  3 | Jack  |     0.00
(3 rows)
```

Next, subtract an amount from Bob’s account:

```console
uniy=> BEGIN;
BEGIN
uniy=> UPDATE accounts
uniy->    SET balance = balance - 1500
uniy->  WHERE id = 1
uniy-> RETURNING *;
 id | name | balance
----+------+---------
  1 | Bob  | 7500.00
(1 row)

UPDATE 1
```
Then, adding the same amount to Alice’s account:

```console
uniy=> UPDATE accounts
uniy->    SET balance = balance + 1500
uniy->  WHERE id = 3
uniy-> RETURNING *;
 id | name | balance
----+------+---------
  3 | Jack | 1500.00
(1 row)

UPDATE 1
```

However, Alice’s account has id `2`. So this was a mistake.

To undo the change, you execute the `ROLLBACK` statement:

```console
uniy=> ROLLBACK;
ROLLBACK
```

Finally, check the balances of all accounts:

```console
uniy=> SELECT * FROM accounts;
 id | name  | balance
----+-------+----------
  1 | Bob   |  9000.00
  2 | Alice | 11000.00
  3 | Jack  |     0.00
(3 rows)
```

```console
uniy=> COMMIT;
WARNING:  there is no transaction in progress
COMMIT
```

When we `ROLLBACK` the transaction is automatically terminated.

As shown clearly in the output, the account balances remain the same as they were before the transaction.

Put it all toegher.

```console
-- begin the transaction
BEGIN;

-- deduct the amount from the account 1
UPDATE accounts
SET balance = balance - 1500
WHERE id = 1;

-- add the amount from the account 3 (instead of 2)
UPDATE accounts
SET balance = balance + 1500
WHERE id = 3;

-- roll back the transaction
ROLLBACK;
```

## SAVEPOINT TRANSACTION

`SAVEPOINT` is a boundary defined within a transaction that allows for **a partial rollback**.

It gives the user the ability to **roll the transaction back to a certain point** without rolling back the entire transaction.

In the previous example, we used the `ROLLBACK` command to discard all the changes done in the `TRANSACTION`. However, the application only required to undo the last `UPDATE` command that increased Jack's account (`id: 3`) balance instead of Alice's account (`id: 2`) balance.

A possible solution to this problem is the use of a `SAVEPOINT`.

```console
uniy=> -- begin the transaction
uniy=> BEGIN;
BEGIN
uniy=> -- deduct the amount from the account 1
uniy=> UPDATE accounts
uniy->    SET balance = balance - 1500
uniy->  WHERE id = 1
uniy-> RETURNING *;
 id | name | balance
----+------+---------
  1 | Bob  | 7500.00
(1 row)

UPDATE 1
uniy=> -- set a SAVEPOINT
uniy=> SAVEPOINT bob_transfer;
SAVEPOINT
```

After the execution of the first `UPDATE` statement we set a savepoint named `bob_transfer` to save the current session transaction.

```console
uniy=> -- add the amount from the account 3 (instead of 2)
uniy=> UPDATE accounts
uniy->    SET balance = balance + 1500
uniy->  WHERE id = 3
uniy-> RETURNING *;
 id | name | balance
----+------+---------
  3 | Jack | 1500.00
(1 row)

UPDATE 1
```

We added by mistake the amount of 1500 to Jack's account instead of Alice's account. Therefore, we want to undo the last `UPDATE` statement. In order to do that we `ROLLBACK` to the `bob_transfer` SAVEPOINT.

```console
uniy=> -- rollback to bob_transfer
uniy=> ROLLBACK TO bob_transfer;
ROLLBACK
uniy=> -- select the data from accounts
uniy=> SELECT *
uniy->   FROM accounts;
 id | name  | balance
----+-------+----------
  2 | Alice | 11000.00
  3 | Jack  |     0.00
  1 | Bob   |  7500.00
(3 rows)
```

After firing ROLLBACK to “my_savepoint,” it will undo all the changes that have been done after the point when the SAVEPOINT was created. The database state is now restored to the point it were after the execution of the first update statement. As a result of this step, the Jack's account balance is not updated.

```console
uniy=> -- add the amount from the account 2
uniy=> UPDATE accounts
uniy->    SET balance = balance + 1500
uniy->  WHERE id = 2
uniy-> RETURNING *;
 id | name  | balance
----+-------+----------
  2 | Alice | 12500.00
(1 row)

UPDATE 1
```

The correct `UPDATE` statement has been executed.

**ludovicopinzari** session.

```console
uniy=# SELECT * FROM accounts;
 id | name  | balance
----+-------+----------
  1 | Bob   |  9000.00
  2 | Alice | 11000.00
  3 | Jack  |     0.00
(3 rows)
```

Clearly, The transaction is not over yet ! The transaction block is still active, so to finish we need to fire either COMMIT or a second ROLLBACK command if we want to rollback the entire transaction.

Please note: We can have multiple SAVEPOINTs within a transaction block.

**usertest** session.

```console
uniy=> COMMIT;
COMMIT
```

**ludovicopinzari** session.

```console
uniy=# SELECT * FROM accounts;
 id | name  | balance
----+-------+----------
  3 | Jack  |     0.00
  1 | Bob   |  7500.00
  2 | Alice | 12500.00
(3 rows)
```

Put it all together:

```console
-- begin the transaction
BEGIN;

-- deduct the amount from the account 1
UPDATE accounts
   SET balance = balance - 1500
 WHERE id = 1;

-- set a SAVEPOINT
SAVEPOINT bob_transfer;

-- add the amount from the account 3 (instead of 2)
UPDATE accounts
   SET balance = balance + 1500
 WHERE id = 3;

-- rollback to bob_transfer
ROLLBACK TO bob_transfer;

-- select the data from accounts
SELECT *
  FROM accounts;

-- add the amount from the account 2
UPDATE accounts
   SET balance = balance + 1500
 WHERE id = 2;

COMMIT;
```

## SQL query error

If there is an **error in the SQL query** then **entire transaction block will be aborted immediately** and any SQL statement that was written before the error will automatically roll back.

```console
uniy=> -- begin the transaction
uniy=> BEGIN;
BEGIN
uniy=> -- deduct the amount from the account 1
uniy=> UPDATE accounts
uniy->    SET balance = balance - 1500
uniy->  WHERE id = 1
uniy-> RETURNING *;
 id | name | balance
----+------+---------
  1 | Bob  | 6000.00
(1 row)

UPDATE 1
uniy=> -- select the data from account (instead of accounts)
uniy=> SELECT *
uniy->   FROM account;
ERROR:  relation "account" does not exist
LINE 2:   FROM account;
               ^
uniy=> SELECT 'Hi';
ERROR:  current transaction is aborted, commands ignored until end of transaction block
uniy=> ROLLBACK;
ROLLBACK
uniy=> SELECT * FROM accounts;
 id | name  | balance
----+-------+----------
  3 | Jack  |     0.00
  1 | Bob   |  7500.00
  2 | Alice | 12500.00
(3 rows)
```

To avoid such a scenario where work is lost, using `SAVEPOINT` is a must.

```console
uniy=> -- begin the transaction
uniy=> BEGIN;
BEGIN
uniy=> -- deduct the amount from the account 1
uniy=> UPDATE accounts
uniy->    SET balance = balance - 1500
uniy->  WHERE id = 1
uniy-> RETURNING *;
 id | name | balance
----+------+---------
  1 | Bob  | 6000.00
(1 row)

UPDATE 1
uniy=> -- set a SAVEPOINT
uniy=> SAVEPOINT bob_transfer;
SAVEPOINT
uniy=> -- select the data from account (instead of accounts)
uniy=> SELECT *
uniy->   FROM account;
ERROR:  relation "account" does not exist
LINE 2:   FROM account;
               ^
uniy=> SELECT *
uniy->   FROM accounts;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
uniy=> ROLLBACK TO bob_transfer;
ROLLBACK
uniy=> SELECT *
uniy->   FROM accounts;
 id | name  | balance
----+-------+----------
  3 | Jack  |     0.00
  2 | Alice | 12500.00
  1 | Bob   |  6000.00
(3 rows)

uniy=> -- undo all changes and terminate transaction
uniy=> ROLLBACK;
ROLLBACK
```

If we check the records in the accounts table:

```console
uniy=> SELECT *
uniy->   FROM accounts;
 id | name  | balance
----+-------+----------
  3 | Jack  |     0.00
  1 | Bob   |  7500.00
  2 | Alice | 12500.00
(3 rows)
```

This is becuase we used the `ROLLBACK` command at the end of the transaction to abort it.

## Benefits of transactions

- Recover from user error: We can `ROLLBACK` (**erase**) a mistake. For instance, I want to delete a particular row from a table. I fired a `DELETE` statement without a `WHERE` condition (by `mistake`). Unfortunately that would delete all records from my table, but I just wanted to delete only a few rows. However, I can easily recover from my mistake if I am inside a  transaction block —  by firing the `ROLLBACK` command.
- As mentioned earlier, other concurrent user sessions would not get affected by a transaction unless it gets locked. In the example below, I have inserted 1 row into a table inside a transaction (following a BEGIN command), and am trying to drop the same table from another session. This will not work, because a lock is held on the table until the end of the transaction.

**Example**

**ludovicopinzari** session.

```console
uniy=# -- begin the transaction
uniy=# BEGIN;
BEGIN
uniy=# -- insert a new accounts record
uniy=# INSERT INTO accounts
uniy-#        (name, balance)
uniy-# VALUES ('John', 0)
uniy-# RETURNING *;
 id | name | balance
----+------+---------
  4 | John |    0.00
(1 row)

INSERT 0 1
```

**usertest** session (terminal)

```console
uniy=> DROP table accounts;
|
```
The session on the `usertest`'s terminal **will be in hung state** until we end the transaction block in `ludovicopinzari`'s terminal.

**ludovicopinzari** session.

```console
uniy=# COMMIT;
COMMIT
```

**usertest** session (terminal)

```console
uniy=> DROP table accounts;
DROP TABLE
uniy=>
```

Please refer to the PostgreSQL community documentation for [locking](https://www.postgresql.org/docs/11/explicit-locking.html)
